C Панфилов А.А., 06-421 
C ==================================================================
C  Файл FORCE.for
C Содержит подпрограмму FORCE
C     ПOДПPOГPAMMA PAЗHECEHИЯ HAГPУЗOK ПО УЗЛАМ
C     BЫЗЫBAETCЯ ИЗ MAIN, вызываемых модулей нет.
C ==================================================================
*     IPR массив управления печатью
*FORCEX - массив состоящий из номеров точек и координат X точек к которым приложена 
*распределенная сила
*CORD - одномерный массив глобальных координат узлов (первые два элемента этого массива 
*являются координатами узла 1 по оси Х и Y соответственно, вторая пара элементов - узла 2 и т.д.).
*R - массив значений усилий в узлах (аналогичен по структуре массиву CORD, только вместо координат
* в нем указываются значения нагрузок по оси Х и Y в узлах);
C NR- число нагруженных узлов 
C ==================================================================
C ================== начало кода FORCE =============================
C                                                для Example 1
C ==================================================================
      SUBROUTINE FORCE(NB,CORD,NRC,DB,IPR,NP,RSUM,R,NDF,DH,NR,
     >PRM1,PRM2,PRM3,PRM4,PRM5,PRM6)
C  +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C  ПOДПPOГPAMMA PAЗHECEHИЯ HAГPУЗOK, BЫЗЫBAETCЯ ИЗ ++MAIN+
C  +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      LOGICAL*1 IPR(50)
      DIMENSION CORD(1),R(1)
      INTEGER T,F1(20),F2(20),F3(40),I1,I2,I3 
      REAL X1,X2,INT_SYM,X0,Y0,DIST,ALPH
       IF(IPR(22)) WRITE(6,22)PRM1,PRM2,PRM3,PRM4,PRM5,PRM6
      IF(IPR(23)) WRITE(6,20)
      NR=0
      I1 = 0
      I2 = 0
      I3 = 0
! Цикл обхода узлов
      DO I = 1,NP
      XI = CORD(2*(I-1)+1) 
      YI = CORD(2*(I-1)+2)
! Распределяем узлы по массивам, в переменных I1,I2,I3 - кол-во узлов в каждом из них
! В массив F1 помещаем узлы, находящиеся на горизонтальной стороне пластины
      IF (YI.GT.24.13) THEN
      I1 = I1 + 1
      F1(I1) = I
      ENDIF
! В массив F2 - узлы вертикальной стороны
      IF (XI.GT.24.13) THEN
      I2 = I2 + 1
      F2(I2) = I
      ENDIF
! Узлы наклонной стороны
      IF (ABS(YI-(34.14-XI)).LT.0.1) THEN
      I3 = I3 + 1
      F3(I3) = I
      ENDIF
      ENDDO
      
! Сортируем массив F1 по убыванию координаты X (отсчет для аргумента функции нагрузки
! начинается в крайней правой точке стороны)
      DO I = 1,I1
      DO J = 1,I1-I
      IF (CORD(2*(F1(J)-1)+1).LT.CORD(2*(F1(J+1)-1)+1)) THEN
      T = F1(J)
      F1(J) = F1(J+1)
      F1(J+1) = T
      ENDIF
      ENDDO
      ENDDO

! Сортировка массива F2 по убыванию переменной Y     
      DO I = 1,I2
      DO J = 1,I2-I
      IF (CORD(2*(F2(J)-1)+2).LT.CORD(2*(F2(J+1)-1)+2)) THEN
      T = F2(J)
      F2(J) = F2(J+1)
      F2(J+1) = T
      ENDIF
      ENDDO
      ENDDO
  
 ! То же для массива F3         
      DO I = 1,I3
      DO J = 1,I3-I
      IF (CORD(2*(F3(J)-1)+2).LT.CORD(2*(F3(J+1)-1)+2)) THEN
      T = F3(J)
      F3(J) = F3(J+1)
      F3(J+1) = T
      ENDIF
      ENDDO
      ENDDO
   
 ! ===== Распределение нагрузок =====
 
 ! Включаем нагрузку q1 по горизонтальной стороне в зависимости от значения PRM1   
      IF (ABS(PRM1-1.0).LT.0.1.OR.ABS(PRM1-3.0).LT.0.1) THEN
      DO I = 1,I1 ! Цикл для всех элементов F1
      XI = CORD(2*(F1(I)-1)+1)
! Расчет пределов интегрирования: половины расстояния от текущего узла до двух соседних
   
      IF (I.EQ.1) THEN ! Для первого элемента левый предел интегрирования равен нулю
       X1 = 0 
      ELSE
      ! Для остальных - расчитываем расстояние.
       X1 = 10.0 - XI - DIST(XI,CORD(2*(F1(I-1)-1)+1),0.0,0.0)/2.0
      ENDIF
! Для последнего элемента правый предел интегрирования равен длине стороны
      IF (I.EQ.I1) THEN
       X2 = 10.0
      ELSE
       X2 = 10.0 - XI + DIST(XI,CORD(2*(F1(I+1)-1)+1),0.0,0.0)/2.0
      ENDIF
      !Вычисление интеграла и запись результата
      R((F1(I)-1)*NDF+2) = INT_SYM(X1,X2,500,0.0,1,PRM4)
      ! Ведем учет всех узлов кроме первого в случае, если нагрузка 
      ! по наклонной стороне включен
      IF (ABS(PRM2).LT.0.1.OR.I.NE.1) THEN
      NR = NR+1
      IF(IPR(23)) WRITE(6,21) NR,F1(I),CORD(2*(F1(I)-1)+1),
     >CORD(2*(F1(I)-1)+2), R((F1(I)-1)*NDF+1),R((F1(I)-1)*NDF+2)
      ENDIF
      ENDDO
      ENDIF
      
      ! Включение нагрузки по вертикальной стенке в зависимости от значения PRM1
! Следующий цикл практически идентичен циклу включения нагрузки по горизонтальной стенке,
! но расчетной координатой является Y
      IF (ABS(PRM1-2.0).LT.0.1.OR.ABS(PRM1-3.0).LT.0.1) THEN
      DO I = 1,I2
      XI = CORD(2*(F2(I)-1)+2)  
      IF (I.EQ.1) THEN
       X1 = 0
      ELSE
       X1 = 10.0 - XI - DIST(0.0,0.0,XI,CORD(2*(F2(I-1)-1)+2))/2.0
      ENDIF
      IF (I.EQ.I2) THEN
       X2 = 10.0
      ELSE
       X2 = 10.0 - XI + DIST(0.0,0.0,XI,CORD(2*(F2(I+1)-1)+2))/2.0
      ENDIF
      R((F2(I)-1)*NDF+1) = INT_SYM(X1,X2,500,0.0,1,PRM4)
      IF (ABS(PRM2).LT.0.1.OR.I.NE.1) THEN
      NR = NR+1
      IF(IPR(23)) WRITE(6,21) NR,F2(I),CORD(2*(F2(I)-1)+1),
     >CORD(2*(F2(I)-1)+2), R((F2(I)-1)*NDF+1),R((F2(I)-1)*NDF+2)
      ENDIF
      ENDDO
      ENDIF
      
! Включение нагрузки по наклонной стороне в зависимости от параметра PRM2
      IF (ABS(PRM2-1.0).LT.0.1) THEN
      ! Рассчитываем угол для прямой, по которой будет приложена нагрузка
      ALPH = ATAN((10.0-24.14)/(24.14-10.))+ACOS(0.0)
      ! Точка начала отсчета
      X0 = 10.0 
      Y0 = 24.142135623
      DO I = 1,I3
      !вычисление расстояния до предыдущего и следующего узлов:
      XI = CORD(2*(F3(I)-1)+1)
      YI = CORD(2*(F3(I)-1)+2)
      IF (I.EQ.1) THEN
      X1 = 0
      ELSE
      X1 = DIST(XI,X0,YI,Y0)-DIST(XI,CORD(2*(F3(I-1)-1)+1),
     >YI,CORD(2*(F3(I-1)-1)+2))/2.0 
      ENDIF
      IF (I.EQ.I3) THEN
      X2 = 20.0  
      ELSE
      X2 = DIST(XI,X0,YI,Y0)+DIST(XI,CORD(2*(F3(I+1)-1)+1),
     >YI,CORD(2*(F3(I+1)-1)+2))/2.0
      ENDIF
      
      ! Запись результата вычисления интеграла в массив R
      R((F3(I)-1)*NDF+1)=R((F3(I)-1)*NDF+1)+
     >INT_SYM(X1,X2,500,PRM3,2,PRM5)*COS(ALPH)
      R((F3(I)-1)*NDF+2)=R((F3(I)-1)*NDF+2)+
     > INT_SYM(X1,X2,500,PRM3,2,PRM5)*SIN(ALPH)
      !Учет узла
      NR = NR+1
      IF(IPR(23)) WRITE(6,21) NR,F3(I),CORD(2*(F3(I)-1)+1),
     >CORD(2*(F3(I)-1)+2), R((F3(I)-1)*NDF+1),R((F3(I)-1)*NDF+2)
      ENDDO
      ENDIF
     
      IF(IPR(23)) PRINT *,"ЧИСЛО НАГРУЖЕННЫХ УЗЛОВ NR=",NR
  21  FORMAT  (2I6,1X,2F10.3,4X,2F9.2)
      IF (NR.NE.0) RETURN
      WRITE(6,6) (I,(R((I-1)*NDF+J),J=1,NDF),I=1,NP)
   6  FORMAT (' HE HAЙДEHЫ TOЧKИ ПPИЛOЖEHИЯ HAГPУЗOK'/8(I4,2G10.2))
  20  FORMAT (' PACПPEДEЛEHИE HAГPУЗOK'/ '     N    УЗEЛ   X-COORD',
     >        '    Y-COORD       * RX *     * RY *')
22     FORMAT (10X,'СВОБОДНЫЕ ПАРАМЕТРЫ (контроль в  FORCE)'
     >/6X,'PRM1',6X,'PRM2',
     >6X,'PRM3',6X,'PRM4',6X,'PRM5',6X,'PRM6'/(2X,6F10.4))
     
      STOP
      END
      
!Функция для рассчета расстояния между точкам M1(X1,Y1) и M2(X2,Y2)
      REAL FUNCTION DIST(X1,X2,Y1,Y2) 
      REAL X1,X2,Y1,Y2
      DIST = SQRT((X2-X1)**2+(Y2-Y1)**2)
      RETURN
      END FUNCTION
      
! Вычисление значения функции нагрузки. NUM - номер функции нагрузки
! (1 для q1, 2 для q2)
      REAL FUNCTION Q(X,A,NUM,K)
      REAL X,A,K
      INTEGER NUM
      IF (NUM.EQ.1) THEN
      Q = K*(-10.0*X*X+200.0*X)
      ELSE 
      Q = K*A*X*X*(COS(0.0785*X)**2.5)
      ENDIF
      END FUNCTION
      
! Вычисление интеграла методом Симпсона:
      REAL FUNCTION INT_SYM(A,B,N,LAM,NUM,K)
      REAL Q,A,B,H,X,LAM,K
      INTEGER N,I,NUM
      
      INT_SYM = Q(A,LAM,NUM,K)+Q(B,LAM,NUM,K)
      H = (B-A)/N !Вычисление шага
      DO I = 1,N-1
         X = A+H*I !Вычисление очередной точки
         
         IF ((-1)**I.GT.0) THEN !Проверка номера точки на четность
               INT_SYM = INT_SYM + 2.0*Q(X,LAM,NUM,K)
         ELSE 
               INT_SYM = INT_SYM + 4.0*Q(X,LAM,NUM,K)
         ENDIF
      ENDDO
      INT_SYM = INT_SYM * H/3.0
      END FUNCTION
      
      
      
      
C ==================================================================
C =================== конец кода FORCE для Example 1 ===================
C ==================================================================
C конец файла FORCE.for
